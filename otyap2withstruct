#define _CRT_SECURE_NO_WARNINGS 
#include <iostream>
#include <fstream>
#include <vector>
#include <cstring>

using namespace std;

/*
	Состояния автомата
	S (в коде называется start)  - начальное состояние
	A (в коде - allRight) - "правильное" состояние
	E (в коде - error) - состояние ошибки
	F (в коде - finish) - выход
			  S   A   E   F
	________________________
рус.гласная | A | A | E |
	________________________
непечатные  |   |   |   |
символы     | S | F | S |
	________________________
др.символы  | E | E | E |
	________________________
*/


enum symbols { russianVowel, space, other };
enum states { start, allRight, error, finish };

//таблица состояний
void createTable(states(*table)[3])
{
	table[start][russianVowel] = allRight;
	table[allRight][russianVowel] = allRight;
	table[error][russianVowel] = error;

	table[start][space] = start;
	table[allRight][space] = finish;
	table[error][space] = start;

	table[start][other] = error;
	table[allRight][other] = error;
	table[error][other] = error;

}

//проверка, является ли символ русской гласной буквой
bool isRusVowel(char c)
{
	return (c == 'А' || c == 'Е' || c == 'Ё' || c == 'И' || c == 'О' || c == 'Э' || c == 'Ю' || c == 'Я' || c == 'Ы' || c == 'У' || c == 'а' || c == 'е' || c == 'ё' || c == 'и' || c == 'о' || c == 'э' || c == 'ю' || c == 'я' || c == 'ы' || c == 'у');
}

//проверяем, чем является введенный символ
symbols check(char c)
{
	if (isRusVowel(c)) return russianVowel; // через функцию выше проверяем, гласная ли это буква
	if (c == '\n' || c == ' ' || c == '\0') return space; // является ли непечатным символом
	return other; // если не подошло ни под одно условие выше, то это посторонний символ
}
struct lexema {
	bool flag;		// флаг корректности лексемы (соответствия заданию)
	char* word;		// текст лексемы
};

//функция для обработки массива слов
void processingWords(char* str, int size, vector <lexema>*& result)
{
	states state = states::start; // текущее состояние	
	int firstPosition = 0; // позиция начала слова;
	states newTable[4][3]; // создаем таблицу состояний
	createTable(newTable);
	lexema lexema;
	lexema.flag = false; // изначально флаг корректности - false, так как слов нет

	for (int position = 0; position < size; ++position) // position - это текущая позиция в строке
	{
		char currentSymbol = str[position];

		// ищем начало слова 
		if (state == states::start && currentSymbol != ' ') firstPosition = position;

		// переход по матрице состояний
		state = newTable[state][check(str[position])];

		// запись корректного слова в выходной список
		if (state !=states::finish) state == states::allRight ? lexema.flag = true : lexema.flag = false; // если пока что слово состоит из гласных букв рус.алфавита, то флагу корректности присваиваем значение true, иначе - false  
		else {
			if (lexema.flag)
			{
				int length = position - firstPosition; // вычисляем длину слова
				lexema.word = new char[length + 1];
				// вычленение подстроки и запись в лексему
				strncpy(&lexema.word[0], &str[0] + firstPosition, length);
				// постановка финализирующего 0
				lexema.word[length] = '\0';
				// запись слова в вектор
				result->push_back(lexema);
				lexema.flag = false;

				state = states::start; // переводим состояние в начальное, чтобы потом начать анализ других слов
			}
		}
	}
}

int main()
{
	// открываем файл, ищем размер, читаем данные из файла
	ifstream fromFile("input.txt");
	int size = 0;
	fromFile.seekg(0, ios::end);
	size = fromFile.tellg(); 
	fromFile.seekg(0, ios::beg);
	char* words = new char[size + 1];
	words[size] = '\0'; 
	fromFile.read(&words[0], size); // чтение из файла
	fromFile.close();

	vector<lexema>* wordsRusVow = new vector<lexema>(); // указатель на динамически выделяемый объект, который динамически выделяет память для хранения элементов. 
	processingWords(words, size + 1, wordsRusVow);

	size = int(wordsRusVow->size()); // размер вектора, который хранит набор корректных слов
	ofstream toFile("output.txt");
	for (int i = 0; i < size; ++i) toFile << wordsRusVow->at(i).word << " "; // вывод в файл
	toFile.close();

	// очищаем память
	delete[] words;
	for (int i = 0; i < int(wordsRusVow->size()); ++i) delete wordsRusVow->at(i).word;
	delete wordsRusVow;
	return 0;
}
